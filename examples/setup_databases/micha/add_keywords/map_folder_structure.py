#!/usr/bin/env python

import os
import re
import sys
import logging

from collections import namedtuple, OrderedDict, Iterable
from functools import partial

if sys.version_info.major >= 3:
    from inspect import signature
else:
    from funcsigs import signature

logger = logging.getLogger('map_folder_structure')


# =========================================================================== #
# Define structures
# =========================================================================== #


Struc = namedtuple('folder', ['name', 'flags', 'mapping', 'subfolders'])
Struc.__new__.__defaults__ = (None, [], {}, [])
Keyword = namedtuple('Keyword', ['name', 'value'])
Keyword.__new__.__defaults__ = (None, None)
Metadata = namedtuple('Metadata', ['name', 'value'])
Metadata.__new__.__defaults__ = (None, None)


# =========================================================================== #
# Define functions
# =========================================================================== #


def map_word_folder(list_words, list_folders):
    """
    Function to map a list of words using list_folders

    Parameters
    ----------
    list_words : List[str]
        List of words to map. e.g ``path.split()``
    list_folders : List[Struc]
        List of ``Struc`` for every folder to map

    Returns
    -------
    list_keywords : List[Keyword]
        List of keywords generated by mapping ``list_folders`` to ``list_words``
    """

    # get the first word of the list
    word = list_words.pop(0)

    # check if the word matches one of the folders in list_folders
    list_keywords = []
    for i, folder in enumerate(list_folders):
        # check by name
        if folder.name == word:
            break
        # check by regex
        elif re.match(folder.name, word):
            break
    else:
        return list_keywords

    # get the matching folder
    folder = list_folders[i]

    # append data
    if isinstance(folder.flags, Iterable):
        list_keywords.extend(folder.flags)
    elif isinstance(folder.flags, Keyword):
        list_keywords.append(folder.flags)

    # append mapping
    for mapping, function in folder.mapping.items():
        if re.match(mapping, word):
            if isinstance(function, Iterable):
                for func in function:
                    list_keywords = apply_mapping(word, list_words, func, list_keywords)
            else:
                list_keywords = apply_mapping(word, list_words, function, list_keywords)

    # append subfolders
    if len(list_words) > 0:
        list_keywords.extend(map_word_folder(list_words, folder.subfolders))

    return list_keywords


def apply_mapping(word, list_words, function, list_keywords):
    """
    Function to apply a mapping function on the [word, list_words]

    If the ``function`` takes ``1`` argument, ``word`` is passed to the function.
    If the ``function`` takes ``2`` arguments, ``word`` and ``list_words`` is passed to the function.
    Parameters
    ----------
    word : str
        Word to map.
    list_words : List[str]
        List of words to map.
    function : function
        Function to apply for mapping.
    list_keywords : List[Keyword]
        List of keywords to append at.

    Returns
    -------
    list_keywords : List[Keyword]
        List of keywords.

    Raises
    ------
    UserWarning
        If the function takes 0 or more then 2 arguments.
    """

    # get the number of parameters of the function
    if type(function) is partial:
        sig = signature(function.func)
        num_args = len(sig.parameters)
        num_args -= len(function.args) + len(function.keywords)
    else:
        sig = signature(function)
        num_args = len(sig.parameters)

    # pass parameter to the functions
    if num_args == 1:
        list_keywords.extend(function(word))
    elif num_args == 2:
        list_keywords.extend(function(word, list_words))
    else:
        raise UserWarning('Not implemented a function with a signature of\n{}'.format(sig))
    return list_keywords


def dict_mapping(word, list_words, adict):
    """
    Function to map a dictionary of keywords.

    dictionary with:
        key = pattern

        value = Keyword or list(Keywords)

    Parameters
    ----------
    word : str
        Word to map.
    list_words : List[str]
        List of words to map.
    adict : dict
        Dictionary with `key = pattern` and `value = Keyword or list(Keywords)`

    Returns
    -------
    list_keywords : List[Keyword]
        List of keywords.

    Raises
    ------
    UserWarning
        if value in dict is not a ``Keyword`` or a list of ``Keyword``.
    """

    list_keywords = []
    for w in [word] + list_words:
        for k, v in adict.items():
            if re.match(k, w):
                if type(v) is Keyword:
                    list_keywords.append(v)
                elif isinstance(v, Iterable) and all([i is Keyword for i in v]):
                    list_keywords.extend(v)
                else:
                    raise UserWarning('value in dict is not a Keyword or a list of Keywords\nk: {}\nv: {}')
    return list_keywords


def map_mapping(word, list_words, adict):
    """
        Function to map a dictionary of functions.

        dictionary with:
            key = pattern

            value = function or list(function)

        Parameters
        ----------
        word : str
            Word to map.
        list_words : List[str]
            List of words to map.
        adict : dict
            Dictionary with `key = pattern` and `value = function or list(function)`

        Returns
        -------
        list_keywords : List[Keyword]
            List of keywords.
        """

    list_keywords = []
    for w in [word] + list_words:
        for k, function in adict.items():
            if re.match(k, w):
                if isinstance(function, Iterable):
                    for func in function:
                        list_keywords = apply_mapping(w, [], func, list_keywords)
                else:
                    list_keywords = apply_mapping(w, [], function, list_keywords)
    return list_keywords


def dict_mapping_with_condition(word, list_words, adict):
    """
    Function to map a dictionary of ``(condition, keywords)``.
    Only maps the keyword if the condition is matched.

    dictionary with:
        key = pattern

        value = ``(condition, Keyword)`` or (condition, List(Keyword))

    Parameters
    ----------
    word : str
        Word to map.
    list_words : List[str]
        List of words to map.
    adict : dict
        Dictionary with `key = pattern` and `value = (condition, Keyword) or (condition, List(Keyword))`

    Returns
    -------
    list_keywords : List[Keyword]
        List of keywords.

    Raises
    ------
    UserWarning
        if value in dict is not a ``Keyword`` or a list of ``Keyword``.
    """

    list_keywords = []
    for w in [word] + list_words:
        for k, (condition, v) in adict.items():
            if re.match(k, w) and any(bool(re.match(w1, condition)) for w1 in [word] + list_words):
                if type(v) is Keyword:
                    list_keywords.append(v)
                elif isinstance(v, Iterable) and all([i is Keyword for i in v]):
                    list_keywords.extend(v)
                else:
                    raise UserWarning('value in dict is not a Keyword or a list of Keywords\nk: {}\nv: {}')

    return list_keywords


def general_mapping(word, list_words):
    """
    Wrapper function to map ``list_general_maps``.

    Parameters
    ----------
    word : str
        Word to map.
    list_words : List[str]
        List of words to map.

    Returns
    -------
    list_keywords : List[Keyword]
        List of keywords.

    Raises
    ------
    UserWarning
        if value in dict is not a ``Keyword`` or a list of ``Keyword``.
    """
    return dict_mapping(word, list_words, list_general_maps)


def generate_keywords(path):
    """
    Function to generate the keywords for a given path
    by splitting into folders and mapping them with ``list_folders``

    Parameters
    ----------
    path : str
        Path to be mapped

    Returns
    -------
    list_keywords : List[Keyword]
        List of keywords.

    """

    list_keywords = map_word_folder(path.split(os.path.sep), list_folders)
    dummy_dict = {}
    for keyword in list_keywords:
        dummy_dict[keyword.name] = keyword
    #     print(len(list_keywords), len(dummy_dict))
    list_keywords = list(dummy_dict.values())
    return list_keywords


# =========================================================================== #
# helper functions
# =========================================================================== #

def remove_version(string):
    """
    Function to remove the version number.
    For folders ending with ``.v[0-9]``

    Parameters
    ----------
    string : str
        Folder name.

    Returns
    -------
    folder_name : str
        Folder name without version tag.

    Examples
    --------
    Example folder

    >>> remove_version('simulation.v3')
    'simulation'

    """
    return re.sub('\.v[0-9]*$', '', string)


def _convert_number_string(number_string):
    """
    Function to convert mixed number character strings to a number.

    Mapping: ``{'K': 1000, 'M': 1000000}``

    Parameters
    ----------
    number_string : str
        Number string to be mapped

    Returns
    -------
    number : int or float
        Converted number, tries to return a integer if possible.

    Examples
    --------
    >>> _convert_number_string('64K')
    64000 # 64 * 1000
    >>> _convert_number_string('0.2M')
    200000 # 0.2 * 1000000
    """
    map_number = {'K': 1000, 'M': 1000000}
    pure_number = re.sub('[A-Z]', '', number_string)
    rv = int(pure_number) if pure_number.isdigit() else float(pure_number)
    for i in number_string:
        if i.isalpha():
            rv *= map_number[i]
    return rv


def _in_text(adict):
    """
    Wrapper to add .* around matches so pattern can be found in words.

    Parameters
    ----------
    adict : dict
        Dictonary with key = `pattern`

    Returns
    -------
    wrapped_dict : dict
         Dictonary with key = `.*pattern.*`
    """

    return dict((".*{}.*".format(k), v) for k, v in adict.items())

# =========================================================================== #
# maintenance functions
# =========================================================================== #


def get_keywords_values(alist):
    """
    Function to get the keywords + values.

    Parameters
    ----------
    alist : List[Struc]
        ``list_folders``

    Returns
    -------
    list_keywords : List[Tuple]
        list of tuples with keyword.name and all found keyword values.

    Examples
    --------
    Show the possible keyword + values
    >>> get_keywords_values(list_folders)
    """
    list_keywords = []
    # get Keywords
    for folder in alist:
        list_keywords.extend([(k.name, [k.value]) for k in folder.flags])
        if len(folder.subfolders) > 0:
            list_keywords.extend(get_keywords_values(folder.subfolders))
    return list_keywords


def get_possible_keywords():
    """
    Function to get the list of possible keywords.

    Returns
    -------
    list_keywords : List[str]
        sorted, unique list of keyword names.

    Examples
    --------
    Show the unique list of possible keyword.
    >>> get_possible_keywords()
    """
    return sorted(list(set([k for k, v in get_keywords_values(list_folders)])))


def get_possible_combinations():
    """
    Function to get the possible combinations of keywords and values.

    Returns
    -------
    possible_combinations : OrderedDict
        Ordered dictionary of the keyword.name and possible values

    Examples
    --------
    get possible combinations of keywords and values.
    >>> get_possible_combinations()
    """
    # condense
    adict = dict()
    for k, v in get_keywords_values(list_folders):
        if k in adict:
            adict[k] += v
        else:
            adict[k] = v

    # return adict
    rv = OrderedDict([(k, sorted(list(set(adict[k])))) for k in sorted(adict.keys())])
    return rv


def show_possible_combinations():
    """
    Show the possible combinations of keywords and values.

    Returns
    -------
    None

    Examples
    --------
    Show possible combinations of keywords and values.
    >>> show_possible_combinations()
    """
    for k, v in get_possible_combinations().items():
        print("'{}'-> {}".format(k, v) if len(v) != 0 else "'{}'".format(k))


# =========================================================================== #
# Mapping
# =========================================================================== #

# ======================================================= #
# mapping functions
# ======================================================= #
# Functions used for mapping

def get_ubiquitin_keywords(word):
    """
    Function to get the keywords for ubiquitin folders.

    Parameters
    ----------
    word : str
        Folder name of a ubiqutin simulation

    Returns
    -------
    list_keywords : List[Keyword]
        List of mapped keywords. ``['protein', 'pH', 'ions', 'c(ions)', 'force field']``
    """

    map_ff = {'charmm': 'CHARMM36m',
              'charmm-raiteri': 'CHARMM36m + Raiteri2015'}

    split = word.split("_")
    protein = split[0]
    ph = int(split[1].split('pH')[-1])
    ions, ion_conc = split[2].split('-')
    ion_conc = 0 if ion_conc == 'neutral' else float(ion_conc.replace('M', ""))
    # split forcefield (.config flag)
    split_forcefield = split[3].split(".")
    forcefield = split_forcefield[0]
    # check if we have a .config flag
    # config = 1 if len(split_forcefield) == 1 else int(split_forcefield[1].split('config-')[-1])

    rv = [Keyword('protein', protein),
          Keyword('pH', ph),
          Keyword('ions', ions),
          Keyword('c(ions)', '{} M'.format(ion_conc)),
          Keyword('force field', map_ff[forcefield]),
          ]

    return rv

# ======================================================= #
# mapping dictionaries
# ======================================================= #
# dictionaries used for mapping


list_general_maps = OrderedDict([
    ('.*metaD.*', Keyword('MetaDynamic')),
    ('metaDynamic', Keyword('MetaDynamic')),
    ('.*_charmm.*', Keyword('force field', 'CHARMM36m')),
    ('.*_charmm-raiteri.*', Keyword('force field', 'CHARMM36m + Raiteri2015')),
    ('.*_SWARM.*', Keyword('SWARM')),
    ('python', Keyword('Python'))

])

dict_polymorphs = {
    'calcite': Keyword('polymorph', 'calcite'),
    'aragonite': Keyword('polymorph', 'aragonite'),
    'vaterite': Keyword('polymorph', 'vaterite')
}

dict_solvation_state = {
    'in_vacuo': Keyword('solvation state', 'in vacuo'),
    'invacuo': Keyword('solvation state', 'in vacuo'),
    'vacuum': Keyword('solvation state', 'in vacuo'),
    'in_aqua': Keyword('solvation state', 'in aqua'),
    'bulk': Keyword('solvation state', 'bulk'),
    'bulkphase': Keyword('solvation state', 'bulk'),
}

dict_system_state = OrderedDict([
    ('crystalline', Keyword('system state', 'crystalline')),
    ('melting', Keyword('system state', 'melting')),
    ('molten', Keyword('system state', 'molten')),
    ('quenching', Keyword('system state', 'quenching')),

])

dict_map_ff = OrderedDict([
    ('.*_raitei.*', Keyword('force field', 'Raiteri2015')),
    ('.*_charmm.*', Keyword('force field', 'CHARMM36m')),
    ('.*_charmm-raiteri.*', Keyword('force field', 'CHARMM36m + Raiteri2015')),
    ('model1', Keyword('force field', '2018_cgmodel_model1')),
    ('model2', Keyword('force field', '2018_cgmodel_model2')),
    ('model3', Keyword('force field', '2018_cgmodel_model3')),
    ('model1_cont.*', Keyword('force field', '2018_cgmodel_model1')),
    ('model2_cont.*', Keyword('force field', '2018_cgmodel_model2')),
    ('model3_cont.*', Keyword('force field', '2018_cgmodel_model3')),
    ('model1\.v.*', Keyword('force field', '2018_cgmodel_model1')),
    ('model2\.v.*', Keyword('force field', '2018_cgmodel_model2')),
    ('model3\.v.*', Keyword('force field', '2018_cgmodel_model3')),
    ('model3\.v.*', Keyword('force field', '2018_cgmodel_model3')),
    ('model[4-9].*', Keyword('force field', 'cg_model_exp')),
    ('model_.*', Keyword('force field', 'cg_model_exp')),
])

map_systems = OrderedDict([
    ('.*calcite_np_.*', lambda x: (Keyword('nanoparticle',
                                           '{} A'.format(remove_version(
                                               re.sub('.*calcite_np_', '', x)
                                           ).split('_')[0].replace('-', '.'))
                                           ),)),
    ('.*aragonite_[0-9]*units.*', lambda x: (Keyword('nanoparticle',
                                                     '{} units'.format(remove_version(
                                                         re.sub('.*aragonite_', '', x)
                                                     ).split('_')[0][:-5])),)),
    ('c.*M_.*CaCO3_.*A.*', lambda x: (Keyword('c(ions)', "{} M".format(x.split('_')[0][1:-1])),
                                      Keyword('n(ions)', int(x.split('_')[1][:-5])),)),
    ('[0-9].*system_[0-9]*CaCO3.*', lambda x: (Keyword('n_atoms', _convert_number_string(x.split('_')[0][:-6])),
                                               Keyword('n(ions)', int(x.split('_')[1][:-5])))),
    ('[0-9].*system.*', lambda x: (Keyword('n_atoms', _convert_number_string(x.split('_')[0][:-6])),)),
])

# ======================================================= #
# mapping routine for folders
# ======================================================= #
# The interessting part
# mapping scheme for folders

list_folders = []

# =====================================================================================#
# methods
# =====================================================================================#

list_folders.append(
    Struc('methods',
          [Keyword('method development')],
          subfolders=[
              Struc('openmm_implementations', [Keyword('OpenMM'), Keyword('force field implementation')]),
              Struc('openpathsampling',
                    [Keyword('OpenPathSampling'), Keyword('method implementation')],
                    subfolders=[Struc('TESTSYSTEMS',
                                      [Keyword('test system')],
                                      subfolders=[Struc('calcite_9.6A', [Keyword('system', 'CaCO3'),
                                                                         Keyword('polymorph', 'calcite'),
                                                                         Keyword('nanoparticle', '9.6A')]),
                                                  Struc('alanine_dipeptide_tps',
                                                        [Keyword('system', 'alanine dipeptide'),
                                                         Keyword('TPS')])
                                                  ])
                                ]
                    ),

          ])
)

# =====================================================================================#
# builds
# =====================================================================================#

list_folders.append(
    Struc('builds',
          [Keyword('system builds')],
          subfolders=[
              Struc('CaCO3', [Keyword('system', 'CaCO3'), Keyword('system state', 'crystalline')],
                    subfolders=[
                        Struc('.*', mapping={'.*': lambda x: (Keyword('polymorph', x.split('_')[0]),
                                                              Keyword('Structure source', "{} ({})".format(
                                                                  ", ".join(s.capitalize() for s in x.split('_')[1:-1]),
                                                                  x.split('_')[-1])),
                                                              )
                                             },
                              subfolders=[Struc('surface', [Keyword('surface')],
                                                subfolders=[
                                                    Struc('surface_.*', mapping={
                                                        '.*invacuo.*': lambda x: (
                                                        Keyword('solvation state', 'in vacuo'),),
                                                        '.*hkl-[0-9]*': lambda x: (
                                                        Keyword('hkl', x.rsplit('_', 1)[-1].split('-')[-1]),),

                                                    })
                                                ])]
                              )
                    ]
                    )

          ]
          ),
)

# =====================================================================================#
# polyacrylacid
# =====================================================================================#

list_folders.append(
    Struc('polyacrylacid', [Keyword('polyacrylic acid')],
          subfolders=[
              Struc('propaneacid_mono_inaqua',
                    [Keyword('system', 'propionic acid'), Keyword('solvation state', 'in aqua')],
                    subfolders=[

                        Struc('.*', mapping={'.*': lambda x: (Keyword('force field', x),
                                                              Keyword('resolution', 'atomistic' if x.split('-')[
                                                                                                       -1] == 'aa' else 'united atom'))})
                    ])
          ])

)

# =====================================================================================#
# Structuredata
# =====================================================================================#

list_folders.append(
    Struc('Structuredata',
          subfolders=[
              Struc(".*",
                    subfolders=[
                        Struc('CaCO3', [Keyword('system', 'CaCO3')],
                              subfolders=[
                                  Struc('.*', mapping={'.*': lambda x: (Keyword('polymorph', x.split('_')[0]),
                                                                        Keyword('Structure source', "{} ({})".format(
                                                                            ", ".join(s.capitalize() for s in
                                                                                      x.split('_')[1:-1]),
                                                                            x.split('_')[-1]))
                                                                        )
                                                       }
                                        )
                              ]
                              ),
                    ])
          ])

)

# =====================================================================================#
# Testsystems
# =====================================================================================#

list_folders.append(
    Struc('Testsystems', [Keyword('test system')],
          subfolders=[
              Struc('methods', [Keyword('test method')],
                    subfolders=[
                        Struc('PLUMED.*', [Keyword('PLUMED')],
                              mapping={'PLUMED_.*': lambda x: (
                              Keyword('collective variables', ", ".join([s.upper() for s in x.split('_', 1)[1:]])),),
                                       '.*': general_mapping},
                              )
                    ])
          ]
          ),
)

# =====================================================================================#
# tutorials
# =====================================================================================#

list_folders.append(
    Struc('tutorials', [Keyword('tutorial')],
          subfolders=[
              Struc('python', [Keyword('PYTHON')])
          ]
          ),
)

# =====================================================================================#
# cg_surfactants
# =====================================================================================#

list_folders.append(
    Struc('cg_surfactants', [Keyword('system', 'cg_surfactant')],
          mapping={'.*': partial(dict_mapping, adict=dict_polymorphs)}
          )
)

# =====================================================================================#
# atomistic_caco3
# =====================================================================================#

list_folders.append(
    Struc('atomistic_caco3', [Keyword('system', 'CaCO3'),
                              Keyword('resolution', 'atomistic'),
                              Keyword('force field', 'Raiteri2015')],
          subfolders=[
              Struc('nanoparticle', [Keyword('nanoparticle')],
                    subfolders=[
                        Struc('in_vacuo', [Keyword('solvation state', 'in vacuo')],
                              subfolders=[
                                  Struc('.*', mapping={'.*': general_mapping, },
                                        subfolders=[
                                            Struc('.*',
                                                  mapping={'.*': partial(dict_mapping, list_words=[],
                                                                         adict=dict_system_state),
                                                           'crystalline': partial(dict_mapping, adict=dict_polymorphs)}
                                                  )
                                        ])
                              ]),
                        Struc('in_aqua', [Keyword('solvation state', 'in vacuo')],
                              subfolders=[
                                  Struc('calcite_.*', [Keyword('polymorph', 'calcite')],
                                        mapping={'.*': lambda x: (
                                        Keyword('nanoparticle', '{}A'.format(x.split('_')[-1])),), })
                              ])
                    ]),  # atomistic_caco3 - nanoparticle
              Struc('surface', [Keyword('surface')],
                    subfolders=[
                        Struc('.*', mapping={'.*': [
                            partial(dict_mapping, list_words=[], adict=dict_solvation_state),
                            partial(dict_mapping, adict=dict_system_state),
                            partial(dict_mapping_with_condition,
                                    adict=dict((k, ('crystalline', v)) for k, v in dict_polymorphs.items())),
                        ], })
                    ]),  # atomistic_caco3 - surface
              Struc('polymorphism', [Keyword('polymorphism')],
                    subfolders=[
                        Struc('Quigley_and_Rodger',
                              [Keyword('MetaDynamic'), Keyword('nanoparticle', '192 units')]),
                        Struc('nanoparticle', [Keyword('nanoparticle')],
                              subfolders=[
                                  Struc('in_vacuo', [Keyword('solvation state', 'in vacuo')],
                                        subfolders=[
                                            Struc('.*',
                                                  mapping={
                                                      'calcite_np_.*': lambda x: (
                                                      Keyword('nanoparticle', x.split('_')[2]),),
                                                      'aragonite_[0-9]*units': lambda x: [Keyword('nanoparticle',
                                                                                                  "{} units".format(
                                                                                                      x.split('_')[1][
                                                                                                      :-5]))],
                                                      '.*': [
                                                          general_mapping,
                                                          partial(dict_mapping, adict=dict_solvation_state),
                                                          partial(dict_mapping, adict=_in_text(dict_system_state)),
                                                      ]
                                                  }
                                                  ),  # in_vacuo - *
                                        ]),  # nanoparticle - in_vacuo
                              ]),  # polymorphism - nanoparticle
                        Struc('metaD', [Keyword('MetaDynamic')],
                              subfolders=[
                                  Struc('PCA_sampling', [Keyword('collective variables', 'PCA')]),
                                  Struc('PIV_based', [Keyword('collective variables', 'PIV')],
                                        mapping={
                                            '.*': [
                                                partial(dict_mapping, adict=_in_text(dict_solvation_state)),
                                                partial(dict_mapping, adict=_in_text(dict_polymorphs)),
                                                partial(dict_mapping, adict=_in_text(dict_system_state)),
                                                partial(map_mapping, adict=map_systems),
                                            ]
                                        }),  # metaD - PIV_based
                                  Struc('steinhardt_parameters', [Keyword('collective variables', 'Steinhardt')],
                                        mapping={
                                            '.*': [
                                                partial(map_mapping, adict=map_systems),
                                                partial(map_mapping, adict={
                                                    'only_q6': lambda x: (Keyword('collective variables', 'Q6'),)})
                                            ]
                                        }),  # metaD - steinhardt_parameters
                              ]),  # polymorphism - metaD
                        Struc('normal_MD',
                              subfolders=[
                                  Struc('analysis', [Keyword('analysis')])
                              ]),  # polymorphism - normal_MD
                    ]),  # atomistic_caco3 - polymorphism
              Struc('nucleation', [Keyword('nucleation'),
                                   Keyword('solvation state', 'in aqua'),
                                   Keyword('system state', 'nucleation'), ],
                    subfolders=[
                        Struc('.*', mapping={
                            '.*': [
                                general_mapping,
                                partial(map_mapping, list_words=[], adict=map_systems),
                            ]
                        })
                    ]),  # atomistic_caco3 - nucleation
              Struc('spinodal_decomposition', [Keyword('spinodal decomposition')],
                    subfolders=[
                        Struc('.*', mapping={
                            '.*': [
                                general_mapping,
                                partial(map_mapping, list_words=[], adict=map_systems),
                            ]
                        })
                    ]),  # atomistic_caco3 - spinodal_decomposition
              Struc('bulkphase_simulations', [Keyword('solvation state', 'bulk')],
                    mapping={'.*': partial(dict_mapping, adict=dict_polymorphs)}
                    ),  # atomistic_caco3 - spinodal_decomposition
          ]  # atomistic_caco3 -> subfolders

          )
)

# =====================================================================================#
# toysystems
# =====================================================================================#

list_folders.append(
    Struc('toysystems', [Keyword('toystystem')],
          subfolders=[
              Struc('nanoparticle_decane', [Keyword('nanoparticle'),
                                            Keyword('system', 'decane'),
                                            Keyword('resolution', 'united atom'),
                                            Keyword('force field', 'trappe-ua')],
                    subfolders=[
                        Struc('.*',
                              mapping={
                                  'metadynamic_.*': lambda x: (Keyword('MetaDynamic'),
                                                               Keyword('collective variables',
                                                                       ", ".join(s.upper() for s in x.split('_')[1:]))),
                              })
                    ]),  # subfolders
          ]),  # toysystems -> subfolders
)  # toysystems

# =====================================================================================#
# ubiquitin
# =====================================================================================#

list_folders.append(
    Struc('ubiquitin', [Keyword('system', 'ubiquitin')],
          subfolders=[
              Struc('atomistic', [Keyword('resolution', 'atomistic')],
                    subfolders=[
                        Struc('ub[_.].*', mapping={
                            '.*': [general_mapping,
                                   get_ubiquitin_keywords]
                        }),  # atomistic - ub.*
                    ]),  # ubiquitin - atomistic
          ]),  # ubiquitin -> subfolders
)  # ubiquitin

# =====================================================================================#
# control_systems
# =====================================================================================#

list_folders.append(
    Struc('control_systems', [Keyword('control systems')],
          subfolders=[
              Struc('calcium_acetate_aq', [Keyword('system', 'calcium acetate'),
                                           Keyword('solvation state', 'in vacuo'),
                                           Keyword('resolution', 'atomistic')],
                    subfolders=[
                        Struc('.*', mapping={
                            '.*': lambda x: [Keyword('force field', x), ]
                        })
                    ])
          ]),  # control_systems -> subfolders
),  # control_systems

# =====================================================================================#
# 2018_cg_model
# =====================================================================================#

list_folders.append(
    Struc('2018_cg_model', [Keyword('system', 'CaCO3'),
                            Keyword('resolution', 'coarse-grained')],
          subfolders=[
              Struc('nucleation', [Keyword('nucleation'),
                                   Keyword('solvation state', 'in aqua'),
                                   Keyword('system state', 'nucleation'), ],
                    subfolders=[
                        Struc('.*', mapping={
                            '.*': [
                                general_mapping,
                                partial(dict_mapping, adict=_in_text(dict_solvation_state)),
                                partial(map_mapping, list_words=[], adict=map_systems), ]
                        },
                              subfolders=[
                                  Struc('model.*', mapping={'.*': partial(dict_mapping, adict=dict_map_ff)})
                              ])
                    ]),  # 2018_cg_model - nucleation
          ]),  # 2018_cg_model -> subfolders
),  # 2018_cg_model

# =====================================================================================#
# cg-model
# =====================================================================================#

list_folders.append(
    Struc('cg-model', [Keyword('system', 'CaCO3'),
                       Keyword('resolution', 'coarse-grained')],
          subfolders=[
              Struc('production',
                    subfolders=[
                        Struc('cg_model_paper',
                              subfolders=[
                                  Struc('nucleation', [Keyword('nucleation'),
                                                       Keyword('solvation state', 'in aqua'),
                                                       Keyword('system state', 'nucleation'), ],
                                        subfolders=[
                                            Struc('.*', mapping={
                                                '.*': [
                                                    general_mapping,
                                                    partial(dict_mapping, adict=_in_text(dict_solvation_state)),
                                                    partial(map_mapping, list_words=[], adict=map_systems), ],
                                                '64Ksystem': lambda x: [Keyword('n_atoms', 64000),
                                                                        Keyword('n(ions)', 400),
                                                                        Keyword('c(ions)', "{} M")]
                                            },
                                                  subfolders=[
                                                      Struc('model.*', mapping={
                                                          '.*': [partial(dict_mapping, adict=dict_map_ff),
                                                                 partial(dict_mapping, adict={
                                                                     'model1': Keyword('force field',
                                                                                       '2018_cgmodel_model3'),
                                                                     'model2': Keyword('force field',
                                                                                       '2018_cgmodel_model2'),
                                                                     'model3': Keyword('force field', 'cg_model_exp'),
                                                                     'model_MAThesis': Keyword('force field',
                                                                                               '2018_cgmodel_model1'),
                                                                 })],
                                                      })
                                                  ])
                                        ]),  # cg_model_paper - nucleation
                              ]),  # production - cg_model_paper
                    ]),  # cg-model - production
              Struc('referencesimulations',
                    subfolders=[
                        Struc('model.*', mapping={
                            '.*': partial(dict_mapping, adict={
                                'model1': Keyword('force field', '2018_cgmodel_model3'),
                                'model2': Keyword('force field', '2018_cgmodel_model2'),
                                'model_MAThesis': Keyword('force field', '2018_cgmodel_model1'),
                            })},
                              subfolders=[
                                  Struc('stability',
                                        subfolders=[
                                            Struc('.*', mapping={
                                                'np.*': lambda x: [
                                                    Keyword('nanoparticle', "{} A".format(x.split('_')[1])), ],
                                                'metaD_np_.*': lambda x: [
                                                    Keyword('nanoparticle', "{} A".format(x.split('_')[2])),
                                                    Keyword('MetaDynamic')],
                                            }),  # stability -> nanoparticle
                                        ])
                              ]),  # referencesimulations -> modelX
                        Struc('compare', [Keyword('analysis')],
                              subfolders=[
                                  Struc('stability', subfolders=[
                                      Struc('.*', mapping={
                                          'np_.*': lambda x: [Keyword('nanoparticle', "{} A".format(x.split('_')[1])), ]
                                      })
                                  ]),  # stability - *
                              ]),  # referencesimulations - compare
                    ]),  # cg-model - referencesimulations
          ]),  # cg-model -> subfolders
),  # cg-model
